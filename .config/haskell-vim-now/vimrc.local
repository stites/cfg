" ========== GENERAL VIM SETTINGS ==========
" ensure that we are using bash if we are in some other terminal
set shell=/bin/bash

" do not care about vi
set nocompatible

" To enable file type detection, use this command in your vimrc
filetype plugin indent on

" ignore case on commands
set ignorecase

" set hybrid-number-d gutters
set relativenumber
set number

" use sane encodings
set encoding=utf-8

" auto-reload files when they are changed (like via git)
set autoread

" set textwidth to be 80 globally
set tw=80

" color anything greater than 80 characters as an error
highlight OverLength ctermbg=Black guibg=Black
" match OverLength '\%>81v.\+'
match OverLength '\%>86v.\+'
" match ErrorMsg '\%>101v.\+'

" Enable search highlighting
set hlsearch

" Enable mouse in all modes
set mouse=a

" vim-sensible enables smarttab. Here, we configure the rest:
" Set the display size of t characters
set tabstop=2

" When hitting , insert combination of t and spaces for this width.
" This combination is deleted as if it were 1 t when using backspace.
set softtabstop=2

" Set code-shifting width. Since smarttab is enabled, this is also the tab
" insert size for the beginning of a line.
set shiftwidth=2

" When inserting tab characters, use spaces instead
set expandtab

" ensure that markdown files have a textwidth of 80
" au BufRead,BufNewFile *.md setlocal textwidth=80

" enable spell checking
" autocmd BufRead,BufNewFile *.md setlocal spell spelllang=en_us
" autocmd FileType gitcommit setlocal spell spelllang=en_us
let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'        " MacOSX/Linux

" setlocal spell spelllang=en_us

" pep8 for python
" au BufNewFile,BufRead *.py
"     \ set tabstop=4
"     \ set softtabstop=4
"     \ set shiftwidth=4
"     \ set textwidth=79
"     \ set expandtab
"     \ set autoindent
"     \ set fileformat=unix

" call vim-flake8 on every file save
autocmd BufWritePost *.py call Flake8()

" ==============================================================================
" vim-pencil
filetype plugin on
" let g:pencil#textwidth = 80

" augroup pencil
"   autocmd!
"   autocmd FileType markdown,mkd call pencil#init({'wrap': 'hard', 'autoformat': 1})
"   autocmd FileType text         call pencil#init({'wrap': 'soft', 'autoformat': 0})
" augroup END

" ==============================================================================
" vim-pad
" let g:pad#dir="~/.stites"

" ==============================================================================
" vim-note
let g:notes_directories = ["~/.stites"]
" let g:notes_title_sync = 'off'

" ==============================================================================
" vim-snipmate
noremap <C-t><Tab> snipMateTrigger


" ==============================================================================
" vim-easymotion
map  <Leader>f <Plug>(easymotion-bd-f)
nmap <Leader>f <Plug>(easymotion-overwin-f)
nmap F <Plug>(easymotion-overwin-f2)

" Turn on case insensitive feature
let g:EasyMotion_smartcase = 1

" ==============================================================================
" https://github.com/sol/hpack
" run hpack automatically on modifications to package.yaml
autocmd BufWritePost package.yaml silent !hpack --silent

" ==============================================================================
" Tab navigation like Firefox.
nnoremap <C-S-Tab> :tabprevious<CR>
nnoremap <C-Tab>   :tabnext<CR>
inoremap <C-S-Tab> <Esc>:tabprevious<CR>i
inoremap <C-Tab>   <Esc>:tabnext<CR>i

" nnoremap <C-t>     :tabnew<CR>
" inoremap <C-t>     <Esc>:tabnew<CR>
nnoremap <C-w>     :tabclose<CR>

" " ==============================================================================
" " sets 'path' to:
" " - the directory of the current file
" " - every subdirectory of the "current directory"
" set path=.,**
" 
" " enables the wildmenu
" set wildmenu
" 
" " ignore specific directories and files
" set wildignore+=*.min.*
" set wildignore+=*.stack-work*
" 
" " case-insensitive search
" set wildignorecase

" ==============================================================================
" == 
" == " Use F11 to toggle between paste and nopaste
" == set pastetoggle=<F11>
" == 
" == " Instead of failing command, present dialog if unsaved changes
" == set confirm
" == 
" == " ===========================================
" == " set up tmux-vim config: https://teamgaslight.com/blog/vim-plus-tmux-a-perfect-match
" == nnoremap <c-j> <c-w>j
" == nnoremap <c-k> <c-w>k
" == nnoremap <c-h> <c-w>h
" == nnoremap <c-l> <c-w>l
" == 
" == " from tmux-navigator
" == let g:tmux_navigator_no_mappings = 1
" == let g:tmux_navigator_save_on_switch = 1
" == 
" == nnoremap <silent> <c-h> :TmuxNavigateLeft<cr>
" == nnoremap <silent> <c-j> :TmuxNavigateDown<cr>
" == nnoremap <silent> <c-k> :TmuxNavigateUp<cr>
" == nnoremap <silent> <c-l> :TmuxNavigateRight<cr>
" == nnoremap <silent> <c-\> :TmuxNavigatePrevious<cr>
" == 
" == auto BufEnter * let &titlestring = "vim"
" == auto BufEnter * let &iconstring  = "vim"
" == 
" == " =======More Natural Splitting=============
" == set splitbelow
" == set splitright
" == 
" == " =====change leader to space============
" == " let mapleader = "\<Space>"
" == " let mapleader = " "
" == 
" == " ===== NerdTree settings=================
" == map <leader>n :NERDTreeToggle<CR>
" == autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
" == let g:NERDTreeDirArrows = 1
" == let g:NERDTreeDirArrowExpandable = '▸'
" == let g:NERDTreeDirArrowCollapsible = '▾'
" == 
" == " =======Markdown instant========
" == " from: https://github.com/suan/vim-instant-markdown
" == let g:instant_markdown_slow = 1 " slow down realtime updates
" == let g:instant_markdown_autostart = 0 "manually trigger preview via the command :InstantMarkdownPreview
" == 
" == " From http://www.stephendiehl.com/posts/vim_2016.html
" == set wildignore+=*\\tmp\\*,*.swp,*.swo,*.zip,.git,.cabal-sandbox
" == set wildmode=longest,list,full
" == set wildmenu
" == set completeopt+=longest
" == 
" == set t_Co=256
" == 
" == set cmdheight=1
" == 
" == " ==========syntastic================
" == map <Leader>s :SyntasticToggleMode<CR>
" == 
" == set statusline+=%#warningmsg#
" == set statusline+=%{SyntasticStatuslineFlag()}
" == set statusline+=%*
" == 
" == let g:syntastic_always_populate_loc_list = 1
" == let g:syntastic_auto_loc_list = 0
" == let g:syntastic_check_on_open = 0
" == let g:syntastic_check_on_wq = 0
" == 
" == " ghc-mod =============================
" == " To hook into GHC’s code competion capabilities we map several keyboard commands to
" == " ghc-mod functions. To use ghc-mod’s case expand feature we highlight the
" == " scrutinized variable and type t + s to expand out the cases.
" == 
" == map <silent> tw :GhcModTypeInsert<CR>
" == map <silent> ts :GhcModSplitFunCase<CR>
" == map <silent> tq :GhcModType<CR>
" == map <silent> te :GhcModTypeClear<CR>
" == 
" == " neco-ghc ===========================
" == " A completion plugin for Haskell, using ghc-mod
" == let g:necoghc_debug = 1
" == 
" == " supertab =============================
" == let g:SuperTabDefaultCompletionType = '<c-x><c-o>'
" == 
" == if has("gui_running")
" ==   imap <c-space> <c-r>=SuperTabAlternateCompletion("\<lt>c-x>\<lt>c-o>")<cr>
" == else " no gui
" ==   if has("unix")
" ==     inoremap <Nul> <c-r>=SuperTabAlternateCompletion("\<lt>c-x>\<lt>c-o>")<cr>
" ==   endif
" == endif
" == 
" == " To enable familiar tab completion we configure supertab to dispatch to neco-ghc’s
" == " tab completion routines instead of the usual local variable completion. After that
" == " we configure necoghc to be the default tab completion method.
" == 
" == let g:haskellmode_completion_ghc = 1
" == autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc
" == 
" == let g:ycm_semantic_triggers = {'haskell' : ['.']}
" == 
" == let g:necoghc_enable_detailed_browse = 1
" == 
" == " So now pressing tab while in a LANGUAGE pragma, import statement, or anywhere in a
" == " subexpression will use neco-ghc’s tab completion routines to find the context
" == " appropriate statement that matches the partial expression under the cursor.
" == 
" == " tabularize =============================
" == " Tabularize allows uniform aligned code formatting based on any textual regex
" == " pagttern. For Haskell there are several common identifiers that we typically align
" == " on; and we can map specific keys to these common patterns.
" == "
" == " For example typing <a>+<-> on the case arm branches will align on the right arrow.
" == 
" == let g:haskell_tabular = 1
" == 
" == vmap a= :Tabularize /=<CR>
" == vmap a; :Tabularize /::<CR>
" == vmap a- :Tabularize /-><CR>
" == 
" == " ctrl-p =============================
" == " Ctrl-p is a fuzzy file search plugin which allows quick browsing of a project 
" == " based on a fuzzy text search of the filename or it’s contents. We’ll bind the 
" == " ctrl-p panel launch to \ + t.
" == 
" == map <silent> <Leader>t :CtrlP()<CR>
" == noremap <leader>b<space> :CtrlPBuffer<cr>
" == " let g:ctrlp_custom_ignore = '\v[\/]dist$'
" == 
" == " Summary
" == " In summary adding these plugins and lines to the .vimrc will introduce several
" == " Haskell specific commands which are bound to these keyboard shortcuts:
" == 
" == " Command
" == "   t + w           Insert type for toplevel declaration
" == "   t + q           Query type of expression under cursor
" == "   t + s           Case split expression under cursor
" == "   t + e           Erase type query
" == "   a + =           Align on equal sign
" == "   a + -           Align on case match
" == "   Ctrl + x + o    Tab complete under cursor
" == "   \ + t           Open fuzzy file finder
" == "   \ + n           Open file explorer
" == "   \ + t           Open fuzzy file finder
" == "   \ + c +         Space Toggle comment of text under cursor
" == "   \ + c + s       Toggle “sexy” comment of text

