#!/usr/bin/env bash

# See https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/ (perma: https://perma.cc/Q3D3-H6CY )
#set -Eeo pipefail
#   / | \
#  |  |  |
#   `-------- 'E' allows us to capture traps like EXIT, DEBUG, RETURN, and ERR in conjunction with 'e'
#     |  |
#      `----- 
#        |
#         `-- 
#
# Missing
# -------
# set -x  : causes bash to print each command before executing it.
# set -u  : causes bash shell to treat unset variables as an error and exit immediately. Defaults set with ${a:-b} will still succeed.
#           Using conditional statements that check if variables are set:
#             if [ -z "${MY_VAR:-}" ]; then echo "MY_VAR was not set"; fi
#

#IFS=$'\n\t'
# ^^^ unofficial bash mode: https://perma.cc/UQ45-72E5
export EDITOR='nvim'
export BROWSER='lynx'
# export PAGER=most
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export HOSTNAME="$HOSTNAME"
set +o vi

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# ========================================================= #
# history and autofill                                      #
# ========================================================= #
# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) export color_prompt=yes;;
    xterm)
      export TERM="xterm-256color"
      export color_prompt=yes;;
    screen)
      export TERM="screen-256color"
      export color_prompt=yes;;
esac

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
export HISTCONTROL=ignoredups:ignorespace:erasedups:ignoreboth

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=2000

# shopt -s histappend   # append to the history file, don't overwrite it
shopt -s nocaseglob     # auto corrects the case
shopt -s checkwinsize   # check the window size after each command and, if
                        # necessary, update the values of LINES and COLUMNS.
shopt -s globstar       # If set, the pattern "**" used in a pathname
                        # expansion context will match all files and zero or
                        # more directories and subdirectories.


# bash automatically fetches the last command that starts with the
# given term: E.G. you type in ‘ssh’ and press the ‘Page Up’ key and bash
# scrolls through your history for this. Store function in .inputrc
export INPUTRC=$HOME/.inputrc

# DEBIAN-BASED:
# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

if [ "$color_prompt" = yes ]; then
  export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
  export PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt


# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/local/share/bash-completion/bash_completion.sh ]; then
    # shellcheck source=/dev/null
    source /usr/local/share/bash-completion/bash_completion.sh

  elif [ -f /usr/share/bash-completion/bash_completion ]; then
    # shellcheck source=/dev/null
    source /usr/share/bash-completion/bash_completion

  elif [ -f /etc/bash_completion ]; then
    # shellcheck source=/dev/null
    source /etc/bash_completion

  # crazy hack for nix
  elif [ -f /nix/store/kn8022ash6nbmr92yk9a02gjfrx808ib-bash-completion-2.8/etc/profile.d/bash_completion.sh ]; then
    # shellcheck source=/dev/null
    source /nix/store/kn8022ash6nbmr92yk9a02gjfrx808ib-bash-completion-2.8/etc/profile.d/bash_completion.sh
  fi
fi

# ========================================================= #
# ls config                                                 #
# ========================================================= #
# some ls aliases
alias tree='tree -C'

if command -v exa > /dev/null 2>&1; then
  alias ls=" exa -s extension"
  alias la=" exa"
  alias l="  exa -s extension --group-directories-first -l"
  alias ll=" exa -s extension --group-directories-first -a -l"
  alias lll="exa -s extension --group-directories-first -aa -l"
elif $(command -v ls) --color > /dev/null 2>&1; then
  # use preferred ls commands
  alias ls=" \$(which ls) --color -C -X --group-directories-first"
  alias la=" \$(which ls) --color -C -A"
  alias l="  \$(which ls) --color -C -A -F -X --group-directories-first"
  alias ll=" \$(which ls) --color -C -A -F -X --group-directories-first --si -i -hl"
  alias lll="\$(which ls) --color -C -A -F -X --group-directories-first --si -i -hl -a"
else
  # use fallback ls commands
  # alias ls=' ls -G'
  alias la=' ls -A'
  alias l='  ls -CF'
  alias ll=' ls -Fhil'
  alias lll='ls -FAilh'
fi

# Relative Jumps:
alias ~='cd ~ '
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    if test -r "$HOME/.dircolors"; then
      eval "$(dircolors -b "$HOME/.dircolors")"
    else
      eval "$(dircolors -b)"
    fi

    #alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
    alias vgrep='vgrep -v'
fi

# ========================================================= #
# initialization scripts which are auto-generated           #
# ========================================================= #
# disabling for speed - you might have to run these on startx

# ===================== #
# .bashrc functions     #
# ===================== #
alias vrc='vim $HOME/.bashrc'
alias src='exec $SHELL'
alias mr='monitors reset'
alias mh='monitors home'
alias ms='monitors sentenai'


# == mail functions for bash == #
alias neomutt="cd ~/.mail/attachments && neomutt"
alias mutt="neomutt"
alias protonmail-bridge="tmux new-session -d -s mail 'Desktop-Bridge --cli'"
function draft {
  local DRAFT_FOLDER=~/.stites/emails/drafts/
  mkdir -p $DRAFT_FOLDER
  local NUM_DRAFTS=$(\exa -l $DRAFT_FOLDER | wc -l)

  if echo $NUM_DRAFTS >> /dev/null; then
    echo "You have $NUM_DRAFTS in $DRAFT_FOLDER"
    sleep 1
  fi
  local NEXT_DRAFT=$(( $NUM_DRAFTS+1 ))
  nvim -c 'set tw=72 et' '+/^$' ${DRAFT_FOLDER}draft_${NEXT_DRAFT}
}


# == ghci to bash == #
alias ":q"=exit
alias ":r"=myReload

# ========================================= #
# TODO: load init configs in plist somehow  #
# ========================================= #
# shellcheck source=/home/stites/.bash/load
[[ ! -f ~/.bash/load  ]] || source "$HOME/.bash/load"

# we can now start using safe_source
safe_source "$HOME/.fonts/*.sh"
safe_path_add "$HOME/.cabal/bin"

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# needed by travis gem
safe_source "$HOME/.travis/travis.sh"

# ========================================== #
#     Silence that fucking hardware bell     #
# ========================================== #
[[ -n "$DISPLAY" ]] && xset b off
# xset b 0 0 0
# setterm -blength 0
# set bell-style none


# # Setting rg as the default source for fzf
# export FZF_DEFAULT_COMMAND='rg --files --hidden'
# # To apply the command to CTRL-T as well
# export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
# export FZF_DEFAULT_OPTS="--bind='ctrl-o:execute(nvim {})+abort'"
# 
# safe_source "$HOME/.fzf/shell/key-bindings.bash"
# [ -f ~/.fzf.bash ] && source ~/.fzf.bash

alias preview="fzf --preview 'bat --color \"always\" {}'"

alias find="fd"
alias cat="bat"
alias ping="prettyping --nolegend"
alias top="htop"
alias du="ncdu --color dark -rr -x --exclude .git --exclude node_modules --exclude .stack-work --exclude dist-newstyle"
alias help="tldr"
alias curl="http"

if command -v keybase &> /dev/null && [ ! -d "$XDG_RUNTIME_DIR" ]; then
  # export XDG_RUNTIME_DIR=/run/user/$USER
  export XDG_RUNTIME_DIR=/tmp/
  mkdir -p $XDG_RUNTIME_DIR
fi


# echo "$XDG_RUNTIME_DIR"
# if [ -n "$SSH_CONNECTION" ] && [ -z "$XDG_RUNTIME_DIR" ] ; then
#   echo "XDG_RUNTIME_DIR $XDG_RUNTIME_DIR"
#   export XDG_RUNTIME_DIR=/tmp/
# fi

# dictd:https://www.unixmen.com/look-dictionary-definitions-via-terminal/
alias define="dict -d gcide "

#export LANG="en_US.UTF-8"
#export LANGUAGE="en_US.en"

# make less more friendly for non-text input files, see lesspipe(1)
( command -v lesspipe.sh &> /dev/null ) && eval "$(SHELL=/bin/sh lesspipe.sh)"

# HOMEMANAGER, TEMPORARILY
# shellcheck disable=1090
source "$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh"

if [ -f /etc/nixos/configuration.nix ] && ( command -v systemctl &> /dev/null ); then
  systemctl status display-manager.service &> /dev/null
  ret=$?
  if [ $ret -ne 0 ]; then
    printf "Non-root user %s without display. Boot X? ([y]|n) " "$(whoami)"
    read -r bootx
    case "$bootx" in
      ""|"y"|"Y")
        systemctl start display-manager.service
        ;;
    esac
  fi
  if [ -z "${TMUX_PANE:-}" ] && command -v neofetch &> /dev/null; then
    neofetch
  fi
fi
