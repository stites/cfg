#!/usr/bin/env bash

# ========================= #
# User-defined functions    #
# ========================= #

# Function safe_path_add
# @description add path to $PATH variable, if it is not already there.
function safe_path_add {
  # OLD WAY OF DOING IT:
  # PATH_FOUND=$(echo "$PATH" | grep -o -E "(^|:)$1" | head -1)
  # if [ -z "$PATH_FOUND" ] && [ -d "$1" ]; then

  if [[ "$PATH" == *"$1"* ]] && [ -d "$1" ]; then
    export PATH="$1:$PATH"
  # else
  #    test -z $PATH_FOUND && echo "$1 not a directory" || echo "$1 in PATH"
  fi
}


# Function safe_prompt_add
# @description add a command to the $PROMPT_COMMAND only if it is not already present
function safe_prompt_add {
  if [[ $PROMPT_COMMAND != *"$1"* ]]; then
    export PROMPT_COMMAND="$1; $PROMPT_COMMAND"
  fi
}

function find_git_branch {
  # Based on: http://stackoverflow.com/a/13003854/170413
  local branch tag_0 tag

  if branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null); then
    tag_0="$(git describe --tags --abbrev=0 2> /dev/null)"
    tag="$(git describe --tags 2> /dev/null)"

    branch="${branch//[^a-z0-9\/]/-}"
    if [[ -n "$tag" ]] && [[ "$tag_0" == "$tag" ]]; then
      branch="tag:${tag//[^a-z0-9\/]/.}"
    elif [[ "$branch" == "HEAD" ]]; then
      branch='detached*'
    fi
    echo $branch
  fi
}

function find_git_dirty {
  if [[ "$(git status --porcelain 2> /dev/null)" != "" ]]; then
    echo '*'
  fi
}

# Function safe_source
function safe_source {
  # File may not exist, so don't follow for shellcheck linting (SC1090).
  # shellcheck source=/dev/null
  [[ ! -f "$1" ]] || source "$1"
}

# Function append_history
# @description After each command, append to the history file and reread it. To be used in $PROMPT_COMMAND
function append_history {
  history -a; history -c; history -r;
}

# Function append_history
# @description log all commands to a logfile. To be used in $PROMPT_COMMAND
function log_all_commands {
   if [ "$(id -u)" -ne 0 ]; then
     echo "$(date '+%Y-%m-%d.%H:%M:%S') $(pwd) $(history 1)" >> ~/.bash/log/bash-history-"$(date '+%Y-%m-%d')".log
   fi
}

# Function myReload
# @description source bashrc if in shell, rebuild stack if in stack project
function myReload {
  # if [ -z "`ls | grep 'stack.yaml'`" ]; then
    exec "$SHELL"
  #else
  #  stack build
  #fi
}

# Function virtualenvPrompt
# @description because of numerous PROMPT_COMMANDs, virtualenv gets overwritten.
# Requires virtual environments to be written to a path including the phrase "virtualenv"
#
# @mutates variable venv_prompt
function virtualenvPrompt {
  if test -z "$VIRTUAL_ENV" ; then
    venv_prompt=""
  else
    venv_prompt="${BLUE}[$(basename \""$VIRTUAL_ENV"\")]${RESET} "
  fi
  export venv_prompt
}

# Function dotFolder
# @description touch personal dot folder if it does not exist
function dotFolder {
  if [ ! -d "$HOME/.stites/" ]; then
    mkdir ~/.stites
  fi
}

# Function notes
# @description open up notes
function notes {
  dotFolder
  vim ~/.stites
}

# Function workingmemory
# @description open up workingmemory
function workingmemory {
  dotFolder
  vim ~/.stites/workingmemory.md
}

# Function stack-intero
# @description run stack ghci with intero as the backend
function stackintero {
  stack ghci --with-ghc intero
}

function retry {
  for _ in 1 2 3 4 5; do
    "$@" && break
    if $?; then
      sleep 15
    fi
  done
}

function note {
  vim "$HOME/.stites/$1"
}

# ========================= #
# Export functions          #
# ========================= #
export -f safe_path_add
export -f safe_source
export -f safe_prompt_add
export -f append_history;
export -f log_all_commands;
export -f myReload
export -f virtualenvPrompt
export -f dotFolder
export -f notes
export -f workingmemory
export -f stackintero
export -f retry
export -f note

# ========================= #
# Add functions to prompt   #
# ========================= #
# safe_prompt_add "log_all_commands; append_history; virtualenvPrompt"

